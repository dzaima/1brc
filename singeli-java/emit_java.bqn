#!/usr/bin/env bqn
Split â† ((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)
Join â† {(â‰ ğ•¨)â†“âˆ¾ ğ•¨âŠ¸âˆ¾Â¨ ğ•©}
SW â† âŠ¢ â‰¡ â‰ âŠ¸â†‘Ëœ

lns â† â€¢FLines"/dev/stdin"

prims â† â€¢HashMapÂ´ <Ë˜â‰[
  âŸ¨"u1", "boolean"âŸ©, âŸ¨"f32", "float"âŸ©, âŸ¨"f64", "double"âŸ©
  âŸ¨"u8", "byte"âŸ©, âŸ¨"u16", "short"âŸ©, âŸ¨"u32", "int"âŸ©, âŸ¨"u64", "long"âŸ©
  âŸ¨"i8", "byte"âŸ©, âŸ¨"i16", "short"âŸ©, âŸ¨"i32", "int"âŸ©, âŸ¨"i64", "long"âŸ©
  âŸ¨"void", "void"âŸ©
]
boxed â† â€¢HashMapÂ´ <Ë˜â‰[
  âŸ¨"u1", "Boolean"âŸ©, âŸ¨"f32", "Float"âŸ©, âŸ¨"f64", "Double"âŸ©
  âŸ¨"u8", "Byte"âŸ©, âŸ¨"u16", "Short"âŸ©, âŸ¨"u32", "Integer"âŸ©, âŸ¨"u64", "Long"âŸ©
  âŸ¨"i8", "Byte"âŸ©, âŸ¨"i16", "Short"âŸ©, âŸ¨"i32", "Integer"âŸ©, âŸ¨"i64", "Long"âŸ©
]
vectors â† â€¢HashMapÂ´ <Ë˜â‰[
  âŸ¨"u8", "ByteVector"âŸ©, âŸ¨"u16", "ShortVector"âŸ©, âŸ¨"u32", "IntVector"âŸ©, âŸ¨"u64", "LongVector"âŸ©
  âŸ¨"i8", "ByteVector"âŸ©, âŸ¨"i16", "ShortVector"âŸ©, âŸ¨"i32", "IntVector"âŸ©, âŸ¨"i64", "LongVector"âŸ©
  âŸ¨"f32", "FloatVector"âŸ©, âŸ¨"f64", "DoubleVector"âŸ©
  âŸ¨"u1", "VectorMask<?>"âŸ© # seems to work fine enough
]
Type â† {
  âŠ‘(âŠ‘ğ•©)âˆŠ"uifv"? prims.Get ğ•©;
  '*'â‰¡âŠ‘ğ•©? "[]"âˆ¾ËœType 1â†“ğ•©;
  ğ•© SW "[1]["? âˆ¾âŸ¨"VectorShuffle<", boxed.Get (1+Â·âŠ‘âŠâŸœ']')âŠ¸â†“ 4â†“ğ•©, ">"âŸ©;
  '['â‰¡âŠ‘ğ•©? vectors.Get (1+âŠ‘ğ•©âŠ']')â†“ğ•©;
  ! "unknown type "âˆ¾ğ•©
}
Arg â† {
  '''â‰¡âŠ‘ğ•©? Â¯1â†“1â†“ğ•©;
  "!0:u1": "false";
  "!1:u1": "true";
  '!'â‰¡âŠ‘ğ•©?
    ğ•© 1âŠ¸â†“â†©
    i â† âŠ‘ğ•©âŠ':'
    n â† iâ†‘ğ•©
    # n âˆ¾âŸœ"L"âŸ((|â€¢ParseFloat n)â‰¥2â‹†31)â†©
    {
      
      "int": n;
      "long": nâˆ¾'L';
      âŠ‘ğ•©<âŠ¸âˆŠ"byte"â€¿"short"? âˆ¾âŸ¨'(',ğ•©,')',nâŸ©;
      !ğ•©
    } Type (1+i)â†“ğ•©
    ;
  '$'â‰¡âŠ‘ğ•©? 1â†“ğ•©;
  ğ•©
}
ArgTup â† {ArgÂ¨ ','Split {ğ•©â†“ËœÂ¯1-âŠ‘'}'âŠËœâŒ½ğ•©} 5â†“ğ•©}
Args â† {'('âˆ¾')'âˆ¾Ëœ Â¯2â†“ âˆ¾ âˆ¾âŸœ", "Â¨ ArgÂ¨ ğ•©}
Lbl â† {â€¢Repr 1+â€¢ParseFloat 1â†“ğ•©}

caseIndent â† "  "

globalCtr â† 0
EmitFn â† { ğ•Š:
  mainLns â† âŸ¨âŸ©
  
  fnDefs â† âŸ¨âŸ© â‹„ Add â† {mainLnsâˆ¾â†©<ğ•© â‹„ @}
  beginLns â† âŸ¨âŸ© â‹„ AddBegin â† {beginLnsâˆ¾â†©<ğ•© â‹„ @}
  
  switch â† âŠ‘"lbl"<âŠ¸âˆŠ âŠ‘Â¨ğ•©
  codeIndent â† (2 + switchÃ—2)â¥Š' '
  
  # find variables local to this label block
  lnum â† +`("lbl"â‰¡âŠ‘)Â¨ ğ•©
  vdef â† (("new"âŠ¸â‰¡âˆ¨"mut"âŠ¸â‰¡)âŠ‘)Â¨ ğ•©
  names â† 1âŠ‘Â¨vdef/ğ•©
  blocal â† â€¢HashMapâŸœ(1Â¨) {((1=+Â´âˆ˜âˆŠ)Â¨ (âŠğ•¨)âŠ”ğ•©) / â·ğ•¨}Â´ (âˆŠâŸœnames âˆ¾ğ•©)âŠ¸/Â¨ âŸ¨âˆ¾ğ•©, (â‰ Â¨ğ•©)/lnumâŸ©
  
  _makeIf â† { # cond "name[FT]?" _makeIf "body;"
    cond â† ğ•¨
    âˆ¾âŸ¨codeIndent, "if (", {'F': "!"âˆ¾cond; 'T': cond; "1==1"}Â¯1âŠ‘ğ•—, ") ", ğ•©âŸ©
  }
  
  
  prevGoes â† 0
  {ğ•Šps:{
    ("new"â‰¡ğ•©) âˆ¨ "mut"â‰¡ğ•©?
      new â† ğ•©â‰¡"new"
      retty â† {4â‰¤â‰ ps? Type 3âŠ‘ps; @}
      void â† {new? "void"â‰¡retty; 0}
      
      name â† 1âŠ‘ps
      local â† blocal.Has name
      
      {ğ•Š: fnDefsâˆ¾â†©< âˆ¾âŸ¨retty, ' ', name, '=', {"u1":"false"; âŠ‘(âŠ‘ğ•©)âˆŠ"iuf"?"0";"null"}3âŠ‘ps, ';'âŸ©}âŸâŠ¢ (Â¬void âˆ¨ Â¬new) âˆ§ Â¬local
      
      atBegin â† "emit"â€¿"'^atbegin'" â‰¡ (0â€¿0â€¿1â€¿0â€¿1â†‘Ëœâ‰ )âŠ¸/ ps
      {atBegin? ps (4âŠ¸â†‘âˆ¾5âŠ¸â†“)â†©; @}
      
      ArrInit â† {âˆ¾âŸ¨"new ", retty, "{", ','Join ArgÂ¨ ğ•©, "}"âŸ©}
      body â† {
        3â‰¡â‰ ps? Arg 2âŠ‘ps;
        "array": ArrInit 4â†“ps;
        "val": {
          ğ•© SW "!tup{"? ArrInit ArgTup ğ•©;
          ğ•© SW "?:*"? âˆ¾âŸ¨"new ", Type 1â†“3âŠ‘ps, '[', âŠ‘':'Split 1â†“ğ•©, ']'âŸ©;
          '?'â‰¡âŠ‘ğ•©? Arg "!0"âˆ¾1â†“ğ•©;
          Arg ğ•©
        } 4âŠ‘ps;
        "emit": {
          ğ•© SW "castmethod "? âˆ¾âŸ¨'(', Type 5âŠ‘ps, ") ", Arg 6âŠ‘ps, '.', 11â†“ğ•©, Args 7â†“psâŸ©;
          ğ•© SW "method "? âˆ¾âŸ¨Arg 5âŠ‘ps, '.', 7â†“ğ•©, Args 6â†“psâŸ©;
          ğ•© SW "op "? {
            body â† âˆ¾âŸ¨Arg 5âŠ‘ps, ' ', 3â†“ğ•©, ' ', Arg 6âŠ‘psâŸ©
            {âŠ‘retty<âŠ¸âˆŠ"byte"â€¿"short"? âˆ¾âŸ¨'(', retty, ") (", body, ')'âŸ©; body}
          } ğ•©;
          "^arr":
            name â† "arr_"âˆ¾â€¢Repr globalCtr+â†©1
            AddGlobal âˆ¾âŸ¨"private final ", ("'static'"â‰¡5âŠ‘ps)/"static ", retty, " ", name, " = ",  ("'init'"â‰¡6âŠ‘ps)â—¶âŸ¨{ğ•Š: âˆ¾âŸ¨"new ",Type 1â†“3âŠ‘ps,'[',â‹ˆâ¼ğ•©,']'âŸ©}, ArrInitâŸ© 7â†“ps, ';'âŸ©
            name;
          "^newarray": âˆ¾âŸ¨"new ", Type 1â†“3âŠ‘ps, '[', 5âŠ‘ps, ']'âŸ©;
          "^load": âˆ¾âŸ¨5âŠ‘ps, '[', 6âŠ‘ps, ']'âŸ©;
          "^store": âˆ¾âŸ¨5âŠ‘ps, '[', 6âŠ‘ps, "] = ", Arg 7âŠ‘psâŸ©;
          # "^promote": âˆ¾âŸ¨'(', Type 5âŠ‘ps, ") ", 6âŠ‘psâŸ©;
          "^cast": âˆ¾âŸ¨'(', retty, ") ", Arg 5âŠ‘psâŸ©;
          "^boolpromote": âˆ¾âŸ¨'(', retty, ") (", Arg 5âŠ‘ps, "?1:0)"âŸ©;
          âˆ¾âŸ¨ğ•©, Args 5â†“psâŸ©
        } Â¯1â†“1â†“4âŠ‘ps;
        "call": âˆ¾âŸ¨CallName 1â†“4âŠ‘ps, Args 6â†“psâŸ©;
        !ğ•©
      } 2âŠ‘ps
      
      asgn â† {void? ""; localâˆ§new? âˆ¾âŸ¨retty,' ',name," = "âŸ©; nameâˆ¾" = "}
      
      {
        atbegin? AddBegin âˆ¾âŸ¨"  ", asgn, body, ';'âŸ©;
        Add âˆ¾âŸ¨codeIndent, asgn, body, ';'âŸ©
      }
      ;
    "ret": Add {"void": codeIndentâˆ¾"return;"; âˆ¾âŸ¨codeIndent, "return ", Arg ğ•©, ';'âŸ©} 1âŠ‘ps;
    
    "lbl": Add âˆ¾âŸ¨caseIndent, "case ", Lbl 1âŠ‘ps, ':'âŸ©;
    
    ğ•© SW "goto"?     Add (Â¯2âŠ‘ps) ğ•© _makeIf âˆ¾âŸ¨"{ switch_num = ", Lbl Â¯1âŠ‘ps, "; continue switch_loop; }"âŸ©;
    ğ•© SW "break"?    Add (Â¯2âŠ‘ps) ğ•© _makeIf âˆ¾âŸ¨"break ",    Â¯1âŠ‘ps, ';'âŸ©;
    ğ•© SW "continue"? Add (Â¯2âŠ‘ps) ğ•© _makeIf âˆ¾âŸ¨"continue ", Â¯1âŠ‘ps, ';'âŸ©;
    
    "beginBlock": Add âˆ¾âŸ¨codeIndent, 1âŠ‘ps, ": {"âŸ© â‹„ codeIndentâˆ¾â†© "  ";
    "beginLoop":  Add âˆ¾âŸ¨codeIndent, 1âŠ‘ps, ": while(true) {"âŸ© â‹„ codeIndentâˆ¾â†© "  ";
    "endBlock":                                 codeIndentâ†“Ëœâ†© 2 â‹„ Add âˆ¾âŸ¨codeIndent, "}"âŸ©;
    "endLoop":    Add âˆ¾âŸ¨codeIndent, "break;"âŸ© â‹„ codeIndentâ†“Ëœâ†© 2 â‹„ Add âˆ¾âŸ¨codeIndent, "}"âŸ©;
    
    ! ğ•©
  }âŠ‘ps â‹„ prevGoes â†© âŠ‘(<âŠ‘ps)âˆŠ"ret"â€¿"goto" â‹„ @}Â¨ ğ•©
  
  AddâŸ(Â¬prevGoes) codeIndent âˆ¾ "return;"
  
  âŸ¨switch, fnDefs, beginLns, mainLnsâŸ©
}

resTop â† âŸ¨âŸ©
resGlobal â† âŸ¨âŸ©
AddGlobal â† {resGlobalâˆ¾â†©<ğ•©â‹„@}

AddGlobal "public class Gen {"(âŠ¢âˆ¾âˆ¾)@+10

lns Ã—âˆ˜â‰ Â¨âŠ¸/â†©
lnsSplit â† {{' 'Â¨âŒ¾((ğ•©=@+160)âŠ¸/) ğ•©}Â¨ ' ' Split ğ•©}Â¨ lns
fnNameMap â† {
  kâ€¿v â† <Ë˜â‰>{âŸ¨3âŠ‘ğ•©, Arg 1âŠ‘ğ•©âŸ©}Â¨ ("export"â‰¡âŠ‘)Â¨âŠ¸/ lnsSplit
  "Cannot export function by multiple names in Java" ! âˆ§Â´âˆŠk
  k â€¢HashMap v
}
CallName â† {ğ•Šn: {fnNameMap.Has ğ•©? fnNameMap.Get ğ•©; n} '$'âˆ¾n}

fnIR â† @
fnLine â† @
lnsSplit { psğ•ŠwholeLine:
  {
    "beginFn":
      fnIR â†© âŸ¨âŸ©
      name â† CallName 1âŠ‘ps
      fnLine â†© âˆ¾âŸ¨"public ", Type 2âŠ‘ps, " ", name, "(", Â¯2â†“âˆ¾{nâ€¿t: âˆ¾âŸ¨Type t, ' ', n, ", "âŸ©}Â¨ <Ë˜ âˆ˜â€¿2â¥Š 4â†“ps, ") {"âŸ©
      ;
    "endFn":
      switchâ€¿defsâ€¿beginâ€¿main â† EmitFn fnIR
      
      AddGlobal fnLine
      resGlobalâˆ¾â†© begin
      { ğ•Š:
        AddGlobal "  int switch_num = 0;"
        AddGlobal "  "âˆ¾' 'Join defs
        AddGlobal "  switch_loop: while(true) switch(switch_num) {"
        AddGlobal âˆ¾âŸ¨caseIndent, "case 0:"âŸ©
      }âŸâŠ¢ switch
      resGlobalâˆ¾â†© main
      AddGlobalâŸswitch "  }"
      AddGlobal "}"
      
      fnIRâ†©@
      ;
    "require": {
      "'staticline": AddGlobal Â¯1â†“20â†“wholeLine;
      "'package": resTop âˆ¾Ëœâ†© <âˆ¾âŸ¨"package ", Â¯1â†“2âŠ‘ps, ';'âŸ©;
      "'import":  resTop âˆ¾ â†© <âˆ¾âŸ¨"import ",  Â¯1â†“2âŠ‘ps, ';'âŸ©;
      "'^unsafe'":
        AddGlobal "private static final Unsafe MY_UNSAFE;"
        AddGlobal "static {"
        AddGlobal "  try {"
        AddGlobal "    Field f = Unsafe.class.getDeclaredField(""theUnsafe"");"
        AddGlobal "    f.setAccessible(true);"
        AddGlobal "    MY_UNSAFE = (Unsafe) f.get(Unsafe.class);"
        AddGlobal "  } catch (Throwable e) { throw new RuntimeException(e); }"
        AddGlobal "}"
        ;
      @
    } 1âŠ‘ps;
    "'//warn": â€¢term.ErrRaw â€¢ToUTF8 (@+10)âˆ¾ËœÂ¯1â†“' 'Join 1â†“ps;
    "constant": {
      AddGlobal âˆ¾âŸ¨"private static final ", Type 2âŠ‘ps, ' ', 1â†“1âŠ‘ps, " = ", "new ", Type 2âŠ‘ps, "{", ','Join ArgTup 3âŠ‘ps, "};"âŸ©
    };
    
    "export": AddGlobal âˆ¾âŸ¨"// todo export"âŸ©;
    
    {fnIRâ‰¡@? AddGlobal ' 'Join ps; fnIRâˆ¾â†©<ps}
    # ! "idk "âˆ¾âŠ‘ps
  } âŠ‘ps
}Â¨ lns

AddGlobalÂ¨ ""â€¿"}"

(â€¢wdpathâ€¢file.At âŠ‘â€¢args) â€¢FLines resTopâˆ¾resGlobal