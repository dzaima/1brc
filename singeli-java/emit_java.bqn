#!/usr/bin/env bqn
Split â† ((âŠ¢-Ëœ+`Ã—Â¬)âˆ˜=âŠ”âŠ¢)
Join â† {(â‰ ğ•¨)â†“âˆ¾ ğ•¨âŠ¸âˆ¾Â¨ ğ•©}
SW â† âŠ¢ â‰¡ â‰ âŠ¸â†‘Ëœ

lns â† â€¢FLines"/dev/stdin"

prims â† â€¢HashMapÂ´ <Ë˜â‰[
  âŸ¨"u1", "boolean"âŸ©
  âŸ¨"u8", "byte"âŸ©, âŸ¨"u16", "short"âŸ©, âŸ¨"u32", "int"âŸ©, âŸ¨"u64", "long"âŸ©
  âŸ¨"i8", "byte"âŸ©, âŸ¨"i16", "short"âŸ©, âŸ¨"i32", "int"âŸ©, âŸ¨"i64", "long"âŸ©
  âŸ¨"void", "void"âŸ©
]
boxed â† â€¢HashMapÂ´ <Ë˜â‰[
  âŸ¨"u1", "Boolean"âŸ©
  âŸ¨"u8", "Byte"âŸ©, âŸ¨"u16", "Short"âŸ©, âŸ¨"u32", "Integer"âŸ©, âŸ¨"u64", "Long"âŸ©
  âŸ¨"i8", "Byte"âŸ©, âŸ¨"i16", "Short"âŸ©, âŸ¨"i32", "Integer"âŸ©, âŸ¨"i64", "Long"âŸ©
]
vectors â† â€¢HashMapÂ´ <Ë˜â‰[
  âŸ¨"u8", "ByteVector"âŸ©
  âŸ¨"i8", "ByteVector"âŸ©
  âŸ¨"u16", "ShortVector"âŸ©
  âŸ¨"i16", "ShortVector"âŸ©
  âŸ¨"u32", "IntVector"âŸ©
  âŸ¨"i32", "IntVector"âŸ©
  âŸ¨"u64", "LongVector"âŸ©
  âŸ¨"i64", "LongVector"âŸ©
  âŸ¨"u1", "VectorMask<?>"âŸ© # extremely wrong; maybe VectorMask<?> works?
]
Type â† {
  âŠ‘(âŠ‘ğ•©)âˆŠ"uifv"? prims.Get ğ•©;
  '*'â‰¡âŠ‘ğ•©? "[]"âˆ¾ËœType 1â†“ğ•©;
  ğ•© SW "[1]["? âˆ¾âŸ¨"VectorShuffle<", boxed.Get (1+Â·âŠ‘âŠâŸœ']')âŠ¸â†“ 4â†“ğ•©, ">"âŸ©;
  '['â‰¡âŠ‘ğ•©? vectors.Get (1+âŠ‘ğ•©âŠ']')â†“ğ•©;
  ! "unknown type "âˆ¾ğ•©
}
Arg â† {
  '''â‰¡âŠ‘ğ•©? Â¯1â†“1â†“ğ•©;
  "!0:u1": "false";
  "!1:u1": "true";
  '!'â‰¡âŠ‘ğ•©?
    ğ•© 1âŠ¸â†“â†©
    i â† âŠ‘ğ•©âŠ':'
    n â† iâ†‘ğ•©
    # n âˆ¾âŸœ"L"âŸ((|â€¢ParseFloat n)â‰¥2â‹†31)â†©
    {
      
      "int": n;
      "long": nâˆ¾'L';
      âŠ‘ğ•©<âŠ¸âˆŠ"byte"â€¿"short"? âˆ¾âŸ¨'(',ğ•©,')',nâŸ©;
      !ğ•©
    } Type (1+i)â†“ğ•©
    ;
  ğ•©}
Args â† {'('âˆ¾')'âˆ¾Ëœ Â¯2â†“ âˆ¾ âˆ¾âŸœ", "Â¨ ArgÂ¨ ğ•©}
Lbl â† {â€¢Repr 1+â€¢ParseFloat 1â†“ğ•©}

resGlobal â† âŸ¨âŸ©
AddGlobal â† {resGlobalâˆ¾â†©<ğ•©â‹„@}
staticDefs â† âŸ¨âŸ©
caseIndent â† "  "

globalCtr â† 0
EmitFn â† { ğ•Š:
  mainLns â† âŸ¨âŸ©
  
  fnDefs â† âŸ¨âŸ© â‹„ Add â† {mainLnsâˆ¾â†©<ğ•© â‹„ @}
  beginLns â† âŸ¨âŸ© â‹„ AddBegin â† {beginLnsâˆ¾â†©<ğ•© â‹„ @}
  
  # find variables local to this label block
  lnum â† +`("lbl"â‰¡âŠ‘)Â¨ ğ•©
  vdef â† (("new"âŠ¸â‰¡âˆ¨"mut"âŠ¸â‰¡)âŠ‘)Â¨ ğ•©
  names â† 1âŠ‘Â¨vdef/ğ•©
  blocal â† â€¢HashMapâŸœ(1Â¨) {((1=+Â´âˆ˜âˆŠ)Â¨ (âŠğ•¨)âŠ”ğ•©) / â·ğ•¨}Â´ (âˆŠâŸœnames âˆ¾ğ•©)âŠ¸/Â¨ âŸ¨âˆ¾ğ•©, (â‰ Â¨ğ•©)/lnumâŸ©
  
  codeIndent â† "    "
  
  _makeIf â† { # cond "name[FT]?" _makeIf "body;"
    cond â† ğ•¨
    âˆ¾âŸ¨codeIndent, "if (", {'F': "!"âˆ¾cond; 'T': cond; "1==1"}Â¯1âŠ‘ğ•—, ") ", ğ•©âŸ©
  }
  
  prevGoes â† 0
  {ğ•Šps:{
    ("new"â‰¡ğ•©) âˆ¨ "mut"â‰¡ğ•©?
      new â† ğ•©â‰¡"new"
      retty â† {4â‰¤â‰ ps? Type 3âŠ‘ps; @}
      void â† {new? "void"â‰¡retty; 0}
      
      name â† 1âŠ‘ps
      local â† blocal.Has name
      
      {ğ•Š: fnDefsâˆ¾â†©< âˆ¾âŸ¨retty, ' ', name, '=', {"u1":"false"; âŠ‘(âŠ‘ğ•©)âˆŠ"iuf"?"0";"null"}3âŠ‘ps, ';'âŸ©}âŸâŠ¢ (Â¬void âˆ¨ Â¬new) âˆ§ Â¬local
      
      atBegin â† "new"â€¿"emit"â€¿"'^atbegin'" â‰¡ (1â€¿0â€¿1â€¿0â€¿1â†‘Ëœâ‰ )âŠ¸/ ps
      {atBegin? ps (4âŠ¸â†‘âˆ¾5âŠ¸â†“)â†©; @}
      
      ArrInit â† {âˆ¾âŸ¨"new ", retty, "{", ','Join ArgÂ¨ ğ•©, "}"âŸ©}
      body â† {
        3â‰¡â‰ ps? Arg 2âŠ‘ps;
        "array": ArrInit 4â†“ps;
        "val": {
          ğ•© SW "!tup{"? ArrInit ArgÂ¨ ','Split {ğ•©â†“ËœÂ¯1-âŠ‘'}'âŠËœâŒ½ğ•©} 5â†“ğ•©;
          '?'â‰¡âŠ‘ğ•©? âˆ¾âŸ¨"new ", Type 1â†“3âŠ‘ps, '[', âŠ‘':'Split 1â†“ğ•©, ']'âŸ©;
          Arg ğ•©
        } 4âŠ‘ps;
        "emit": {
          ğ•© SW "castmethod "? âˆ¾âŸ¨'(', Type 5âŠ‘ps, ") ", Arg 6âŠ‘ps, '.', 11â†“ğ•©, Args 7â†“psâŸ©;
          ğ•© SW "method "? âˆ¾âŸ¨Arg 5âŠ‘ps, '.', 7â†“ğ•©, Args 6â†“psâŸ©;
          ğ•© SW "op "? âˆ¾âŸ¨Arg 5âŠ‘ps, ' ', 3â†“ğ•©, ' ', Arg 6âŠ‘psâŸ©;
          "^arr":
            name â† "arr_"âˆ¾â€¢Repr globalCtr+â†©1
            AddGlobal âˆ¾âŸ¨"private final ", ("'static'"â‰¡5âŠ‘ps)/"static ", retty, " ", name, " = ",  ("'init'"â‰¡6âŠ‘ps)â—¶âŸ¨{ğ•Š: âˆ¾âŸ¨"new ",Type 1â†“3âŠ‘ps,'[',â‹ˆâ¼ğ•©,']'âŸ©}, ArrInitâŸ© 7â†“ps, ';'âŸ©
            name;
          "^newarray": âˆ¾âŸ¨"new ", Type 1â†“3âŠ‘ps, '[', 5âŠ‘ps, ']'âŸ©;
          "^load": âˆ¾âŸ¨5âŠ‘ps, '[', 6âŠ‘ps, ']'âŸ©;
          "^store": âˆ¾âŸ¨5âŠ‘ps, '[', 6âŠ‘ps, "] = ", Arg 7âŠ‘psâŸ©;
          # "^promote": âˆ¾âŸ¨'(', Type 5âŠ‘ps, ") ", 6âŠ‘psâŸ©;
          "^cast": âˆ¾âŸ¨'(', retty, ") ", Arg 5âŠ‘psâŸ©;
          âˆ¾âŸ¨ğ•©, Args 5â†“psâŸ©
        } Â¯1â†“1â†“4âŠ‘ps;
        !ğ•©
      } 2âŠ‘ps
      
      asgn â† {void? ""; localâˆ§new? âˆ¾âŸ¨retty,' ',name," = "âŸ©; nameâˆ¾" = "}
      
      {
        atbegin? AddBegin âˆ¾âŸ¨"  ", asgn, body, ';'âŸ©;
        Add âˆ¾âŸ¨codeIndent, asgn, body, ';'âŸ©
      }
      ;
    "ret": Add {"void": codeIndentâˆ¾"return;"; âˆ¾âŸ¨codeIndent, "return ", Arg ğ•©, ';'âŸ©} 1âŠ‘ps;
    
    "lbl": Add âˆ¾âŸ¨caseIndent, "case ", Lbl 1âŠ‘ps, ':'âŸ©;
    
    ğ•© SW "goto"?     Add (Â¯2âŠ‘ps) ğ•© _makeIf âˆ¾âŸ¨"{ switch_num = ", Lbl Â¯1âŠ‘ps, "; continue switch_loop; }"âŸ©;
    ğ•© SW "break"?    Add (Â¯2âŠ‘ps) ğ•© _makeIf âˆ¾âŸ¨"break ",    Â¯1âŠ‘ps, ';'âŸ©;
    ğ•© SW "continue"? Add (Â¯2âŠ‘ps) ğ•© _makeIf âˆ¾âŸ¨"continue ", Â¯1âŠ‘ps, ';'âŸ©;
    
    "beginBlock": Add âˆ¾âŸ¨codeIndent, 1âŠ‘ps, ": {"âŸ© â‹„ codeIndentâˆ¾â†© "  ";
    "beginLoop":  Add âˆ¾âŸ¨codeIndent, 1âŠ‘ps, ": while(true) {"âŸ© â‹„ codeIndentâˆ¾â†© "  ";
    "endBlock":                                 codeIndentâ†“Ëœâ†© 2 â‹„ Add âˆ¾âŸ¨codeIndent, "}"âŸ©;
    "endLoop":    Add âˆ¾âŸ¨codeIndent, "break;"âŸ© â‹„ codeIndentâ†“Ëœâ†© 2 â‹„ Add âˆ¾âŸ¨codeIndent, "}"âŸ©;
    
    ! ğ•©
  }âŠ‘ps â‹„ prevGoes â†© âŠ‘(<âŠ‘ps)âˆŠ"ret"â€¿"goto" â‹„ @}Â¨ ğ•©
  
  AddâŸ(Â¬prevGoes) codeIndent âˆ¾ "return;"
  
  âŸ¨fnDefs, beginLns, mainLnsâŸ©
}



fnIR â† @
fnLine â† @
firstFn â† 1
{
  âŸ¨âŸ©: ğ•©;
  ps â† {' 'Â¨âŒ¾((ğ•©=@+160)âŠ¸/) ğ•©}Â¨ ' ' Split allâ†ğ•©
  {
    "beginFn":
      fnIR â†© âŸ¨âŸ©
      { ğ•Š:
        AddGlobal "public class Gen {"(âŠ¢âˆ¾âˆ¾)@+10
        AddGlobalÂ¨ staticDefs
        staticDefs â†© @
        firstFn â†© 0
      }âŸâŠ¢ firstFn
      fnLine â†© âˆ¾âŸ¨"public ", Type 2âŠ‘ps, " ", {ğ•©â†“Ëœ1+âŠ‘ğ•©âŠ'_'} 1âŠ‘ps, "(", Â¯2â†“âˆ¾{nâ€¿t: âˆ¾âŸ¨Type t, ' ', n, ", "âŸ©}Â¨ <Ë˜ âˆ˜â€¿2â¥Š 4â†“ps, ") {"âŸ©
      ;
    "endFn":
      defsâ€¿beginâ€¿main â† EmitFn fnIR
      
      AddGlobal fnLine
      resGlobalâˆ¾â†© begin
      AddGlobal "  int switch_num = 0;"
      AddGlobal "  "âˆ¾' 'Join defs
      AddGlobal "  switch_loop: while(true) switch(switch_num) {"
      AddGlobal âˆ¾âŸ¨caseIndent, "case 0:"âŸ©
      resGlobalâˆ¾â†© main
      AddGlobalÂ¨ "  }"â€¿"}"
      
      fnIRâ†©@
      ;
    "require": {
      "'staticline"â‰¡1âŠ‘ps? !staticDefsâ‰¢@ â‹„ staticDefsâˆ¾â†©< Â¯1â†“20â†“all;
      "'package"â‰¡1âŠ‘ps? resGlobal âˆ¾Ëœâ†© <âˆ¾âŸ¨"package ", Â¯1â†“2âŠ‘ps, ';'âŸ©;
      "'import" â‰¡1âŠ‘ps?      AddGlobal âˆ¾âŸ¨"import ",  Â¯1â†“2âŠ‘ps, ';'âŸ©;
      @
    };
    
    "export": AddGlobal âˆ¾âŸ¨"// todo export"âŸ©;
    
    {fnIRâ‰¡@? AddGlobal ' 'Join ps; fnIRâˆ¾â†©<ps}
    # ! "idk "âˆ¾âŠ‘ps
  } âŠ‘ps
}Â¨ lns

AddGlobalÂ¨âŸ(Â¬firstFn) ""â€¿"}"

(â€¢wdpathâ€¢file.At âŠ‘â€¢args) â€¢FLines resGlobal